<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to My World">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Welcome to My World">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome to My World">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Welcome to My World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Welcome to My World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/05/04/Leetcode15/" itemprop="url">
                  Leetcode-15 Three Sum
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-05-04T21:45:56+08:00" content="2017-05-04">
              2017-05-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>题目要求：给定一个数组nums，找出和为0的所有三元组集合。</p>
<p>示例：nums = [-1, 0, 1, 2, -1, -4]，和为0的三元组集合 = [[-1, 0, 1], [-1, -1, 2]]。</p>
<p>思路：将数组排序后，指针指定一个元素后，对该元素之后的元素进行2sum运算，考虑到不能有重复结果，所以需要跳过重复元素。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        int N = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArraysList&lt;&gt;();</span><br><span class="line">        if (nums == null || N == 0 || N &lt; 3)</span><br><span class="line">            return result;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; N-2; i++) &#123;</span><br><span class="line">            // 跳过重复元素</span><br><span class="line">            if (i &gt; 0 &amp;&amp; num[i-1] == nums[i])</span><br><span class="line">                continue;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = N - 1;</span><br><span class="line">            int target = -nums[i];</span><br><span class="line">            // 对之后的元素进行2sum</span><br><span class="line">            twoSum(nums, left, right, target, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void twoSum(int[] nums, int left, int right, int target, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                list.add(-target);</span><br><span class="line">                list.add(nums[left]);</span><br><span class="line">                list.add(nums[right]);</span><br><span class="line">                result.add(list);</span><br><span class="line"></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line"></span><br><span class="line">                // 从左边跳过重复元素</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[left-1] == nums[left])</span><br><span class="line">                    left++;</span><br><span class="line">                // 从右边跳过重复元素</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[right] == nums[right+1])</span><br><span class="line">                    right--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 和小于target，增大left的值</span><br><span class="line">            else if (nums[left] + nums[right] &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            // 和大于target，减小right的值</span><br><span class="line">            else</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/05/03/Leetcode11/" itemprop="url">
                  Leetcode-11 Container With Most Water
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-05-03T21:12:55+08:00" content="2017-05-03">
              2017-05-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>题目要求：给定一个非负的整型数组，元素a[i]代表坐标(i, a[i])，得到一组每个点到x轴的垂线，选出两条垂线和x轴构成水箱，求围成的最大的面积。</p>
<p>思路：<br>左右两个指针扫描数组，计算面积。假设找到最佳的两条线为left，right，易知left左边没有比left更高的垂线，right右边没有比right更高的垂线，即最佳的组合在当前候选的left和right的范围内。收缩底边长度，增大高，当left的高度大于right的，right向左扫描，反之left向右扫描，求出最大面积。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int N = height.length;</span><br><span class="line">        if (N &lt; 2)</span><br><span class="line">            return 0;</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = N - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int currArea = (right - left) * Math.min(height[left], height[right]);</span><br><span class="line">            maxArea = Math.max(maxArea, currArea);</span><br><span class="line">            if (height[left] &gt; height[right])</span><br><span class="line">                right--;</span><br><span class="line">            else</span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/04/30/Leetcode4/" itemprop="url">
                  Leetcode-4 Median of Two Sorted Arrays
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-04-30T22:07:09+08:00" content="2017-04-30">
              2017-04-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>题目要求：给定两个有序数组nums1、nums2，找到合并后数组的中位数。</p>
<p>示例：nums1 = [1, 3]，nums2 = [2]，中位数2.0</p>
<p>思路：</p>
<ol>
<li>传统思路，将两个数组合并起来再排序，找到中位数。</li>
<li>将问题扩展为在两个有序数组中找到合并后第K个数的问题。</li>
</ol>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 采用第二种思路</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int m = nums1.length;</span><br><span class="line">        int n = nums2.length;</span><br><span class="line">        int total = m + n;</span><br><span class="line">        // 奇数</span><br><span class="line">        if (total % 2 != 0) &#123;</span><br><span class="line">            return findKth(nums1, 0, m-1, nums2, 0, n-1, total/2 + 1);  // 第total/2+1个元素 </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            double x = findKth(nums1, 0, m-1, nums2, 0, n-1, total/2);</span><br><span class="line">            double y = findKth(nums1, 0, m-1, nums2, 0, n-1, total/2 + 1);</span><br><span class="line">            return (x + y) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  指针从1开始计数</span><br><span class="line">    private double findKth(int[] a, int aLeft, int aRight, int[] b, int bLeft, int bRight, int k) &#123;</span><br><span class="line">        int m = aRight - aLeft + 1;  // 当前a的扫描长度</span><br><span class="line">        int n = bRight - bLeft + 1;  // 当前b的扫描长度</span><br><span class="line">        if (m &gt; n)</span><br><span class="line">            return findKth(b, bLeft, bRight, a, aLeft, aRight, k);</span><br><span class="line">        if (m == 0)</span><br><span class="line">            return b[k-1];</span><br><span class="line">        if (k == 1)</span><br><span class="line">            return Math.min(a[aLeft], b[bLeft]);</span><br><span class="line"></span><br><span class="line">        int partA = Math.min(m, k/2);  // a的指针偏移量</span><br><span class="line">        int partB = k - partA;  // a指针偏移了partA，在合并后的数组中，b指针偏移k-partA</span><br><span class="line"></span><br><span class="line">        // a和b哪个偏移后的数值小，说明Kth大于哪个，证明见下文。则可忽略小于偏移量的那些元素。</span><br><span class="line">        if (a[aLeft + partA - 1] &gt; b[bLeft + partB - 1])</span><br><span class="line">            return findKth(a, aLeft, aRight, b, bLeft+partB, bRight, k-partB);</span><br><span class="line">        else if (a[aLeft + partA - 1] &lt; b[bLeft + partB -1])</span><br><span class="line">            return findKth(a, aLeft+partA, aRight, b, bLeft, bRight, k-partA);</span><br><span class="line">        else</span><br><span class="line">            // a[aLeft+partA-1] == b[bLeft+partB-1]，找到Kth</span><br><span class="line">            return a[aLeft + partA - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：考虑一种情况，假设a和b的个数都大于k/2，设p=k/2-1，如果a[p] &lt; b[p]，则合并后Kth &gt; a[p]<br>证明：用反证法，假设当a[p] &lt; b[p]时，kth &lt; a[p]，不妨令a[p]是合并后第k+1个数。于是，a中有p个数小于a[p]，由假设知b中最多只有p个数小于a[p]，所以总共有2p=k-2个数小于a[p]。a[p]是第k+1个数并且a[p]之前有k-2个数，这是矛盾的，故得证Kth &gt; a[p]。<br>同理，当a[p] &gt; b[p]时，Kth &gt; b[p]，当a[p] == b[p]时，Kth==a[p]==b[p]</p>
<p>在求Kth时，从相对更短的数组入手来计算偏移量p，主要是比较偏移后元素的大小。如果是上文中假设的情况，则直接取k/2，否则取数组长度，即Math.min(k/2, m)。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/04/30/Leetcode1/" itemprop="url">
                  Leetcode-1 Two Sum
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-04-30T21:38:18+08:00" content="2017-04-30">
              2017-04-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>题目要求：给定一个数组nums以及一个数target，求出和为target的两个元素的索引。</p>
<p>示例：nums = [2, 7, 11, 15], target = 9，因为nums[0] + nums[1] = 2 + 7 = 9,所以返回[0, 1]</p>
<p>思路：</p>
<ol>
<li>传统的暴力方法，两次遍历数组，求出所有二元组的和，复杂度O(n^2)</li>
<li>使用Map，数值(key)-索引(value)，遍历一次数组，根据当前nums[i]在Map中查找target-nums[i]</li>
</ol>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int N = nums.length;</span><br><span class="line">        if (N &lt; 2)</span><br><span class="line">            return null;</span><br><span class="line">        int[] result = new int[2];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (map.containsKey(target-nums[i]) &#123;</span><br><span class="line">                result[0] = map.get(target-num[i]);</span><br><span class="line">                result[1] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/21/Java内存模型1/" itemprop="url">
                  Java内存模型(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-21T14:08:44+08:00" content="2017-03-21">
              2017-03-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><p>现代计算机硬件架构的简单图示：<br><img src="/images/java-memory-model-1.png" alt="&quot;Model&quot;"><br>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。<br>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。<br>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。<br>一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。<br>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。<br>当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</p>
<h3 id="内存数据存储"><a href="#内存数据存储" class="headerlink" title="内存数据存储"></a>内存数据存储</h3><p>提出问题：<strong>指令和数据都存放在内存中，那么CPU怎么区分是指令还是数据呢？</strong><br>这是一个很大的问题，就简单从这两个方面来分析</p>
<ul>
<li>从时间上<br>取指令事件发生在指令周期的第一个CPU周期中，即发生在“取指令”阶段，指令周期的长短与指令的复杂程度有关，而取数据事件发生在指令周期的后面几个CPU周期中，即发生在“执行指令”阶段。</li>
<li>从空间上<br>如果取出的代码是指令，那么一定送往指令寄存器，如果取出的代码是数据，那么一定送往运算器。例如：8086采用分段存储管理方式，CPU将CS:IP指向的内存单元的内容看作指令。因为任何时候，CPU用CS:IP合成指令的物理地址，在执行指令的周期，CPU读DS段去找数据。<br>于是有这样的内存模型：<br><img src="/images/java-memory-model-6.png" alt="&quot;MemoryModel&quot;"><br>每当一个程序被执行，系统就要为它开启一个进程，并且为它分配内存。从低址区到高址区，分成几个不同的区域。</li>
<li>低址：存放程序代码本身。（例如8086的CS寄存器中保存的段地址指向的位置）</li>
<li>次低址：存放全局变量，无论是初始化的还是未初始化的。</li>
<li>中址：就是堆（Heap）和堆栈（Stack）的区域。用来储存进程运行过程中产生的变量。</li>
<li>最高址：为系统额外预留的空间。我们无法操作。</li>
</ul>
<p>stack(堆栈)<br>从高址区往下延展。用来存储Scoped Variable(限域变量)。简单说就是已知存储空间以及生命周期的变量。为什么stack效率高呢？因为变量大小确定，都是紧挨着储存的，在堆栈中创建和释放储存空间只要一条汇编语言，分别是将栈顶指针向下和向上移动。而stack本身又是LIFO（Last in First out）的，所以效率极高。<br>heap(堆)<br>从较低地址区往上移动。heap是个动态内存池。从下面的图我们看的很清楚，heap不像stack那样是数据是连续的，而且使用LIFO机制。heap的数据是不连续的，动态随便乱贴的。创建和释放效率都不高。<br><img src="/images/java-memory-model-8.png" alt="&quot;Heap-Stack&quot;"></p>
<p>至于是大端存储还是小端存储的方式在这里就不做过多的讨论了：<br><img src="/images/java-memory-model-7.png" alt="&quot;Big-Endian-Little-Endian&quot;"></p>
<h3 id="Java内存模型内部原理"><a href="#Java内存模型内部原理" class="headerlink" title="Java内存模型内部原理"></a>Java内存模型内部原理</h3><p>Java内存模型把Java虚拟机内部划分为</p>
<ul>
<li>线程栈（堆栈，Stack == Thread Stack）</li>
<li>堆（Heap）<br>“引用”存放在Stack中，Object存放在Heap中<br>这张图演示了Java内存模型的逻辑视图。<br><img src="/images/java-memory-model-2.png" alt="&quot;JavaModel&quot;"><br>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。<br>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。<br>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。<br>示例代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 假设有两个线程Thread1、Thread2</span><br><span class="line">public class MyRunnable implements Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        methodOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodOne() &#123;</span><br><span class="line"></span><br><span class="line">        // 本地变量，存放在Thread Stack中</span><br><span class="line">        int localVariable1 = 45;</span><br><span class="line"></span><br><span class="line">        // 对象Object3存放在Heap中，引用存放在Thread Stack中</span><br><span class="line">        MySharedObject localVariable2 = MySharedObject.sharedInstance;</span><br><span class="line"></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodTwo() &#123;</span><br><span class="line">        // 对象Object1、Object5存放在Heap中，引用存放在Thread Stack中</span><br><span class="line">        Integer localVariable1 = new Integer(99);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MySharedObject &#123;</span><br><span class="line"></span><br><span class="line">    // 指向MyShareObject实例的静态变量（Object3），随着类定义存放在Heap中</span><br><span class="line">    // 这个对象可以被持有该对象引用(localVariable2)的线程T1、T2访问</span><br><span class="line">    // 如果调用Object3的同一个方法，T1、T2会创建一个该对象本地成员变量的私有拷贝</span><br><span class="line">    public static final MySharedObject sharedInstance = new MySharedObject();</span><br><span class="line"></span><br><span class="line">    // 存放在Heap中的成员变量引用（Object1、Object5）</span><br><span class="line">    public Integer object2 = new Integer(22);</span><br><span class="line">    public Integer object4 = new Integer(44);</span><br><span class="line"></span><br><span class="line">    // 成员变量存放在Heap中</span><br><span class="line">    public long member1 = 12345;</span><br><span class="line">    public long member1 = 67890;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。<br><img src="/images/java-memory-model-3.png" alt="&quot;LocalVariable&quot;"></p>
<h3 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h3><p><img src="/images/java-memory-model-4.png" alt="&quot;bridge&quot;"><br>Java内存模型模拟了硬件内存架构，如果把Heap比作内存，把Thread Stack比作多个处理器与缓存层的话，当有多个线程时，每个Stack从内存中将数据拷贝，变更以后再写回内存时就会出现数据不一致的情况。<br><img src="/images/java-memory-model-5.png" alt="&quot;disaccord&quot;"><br>Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。但这只能保证用volatile读到的数据是内存中最新的，但在copy到Thread Stack以后其他线程再改变数据就会出现问题，这就是存在竞争。<br>为了解决这个问题，可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区（读取临界资源）。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
<p>参考：</p>
<ul>
<li><a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="external">《Java内存模型》</a></li>
<li><a href="http://blog.csdn.net/cc_net/article/details/10419645" target="_blank" rel="external">《计算机原理学习（1）– 冯诺依曼体系和CPU工作原理》</a></li>
<li><a href="http://blog.csdn.net/cc_net/article/details/11097267" target="_blank" rel="external">《计算机原理学习（3）– 内存工作原理》</a></li>
<li><a href="http://www.ciaoshen.com/java/thinking%20in%20java/2016/03/06/tij4-2.html" target="_blank" rel="external">《Thinking in Java》 Note: Chapter 2 - Everything is an Object</a></li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/16/Java集合框架学习8/" itemprop="url">
                  Java集合框架学习(8)——Set接口和SortedSet接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-16T09:38:11+08:00" content="2017-03-16">
              2017-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>Set 是不包含重复元素的 Collection。更确切地讲，Set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。声明的方法都是直接继承自父接口Collection的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    int size();</span><br><span class="line"></span><br><span class="line">    boolean isEmpty();</span><br><span class="line"></span><br><span class="line">    boolean contains(Object o);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line"></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    boolean add(E e);</span><br><span class="line"></span><br><span class="line">    boolean remove(Object o);</span><br><span class="line"></span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line"></span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line"></span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line"></span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    boolean equals(Object o);</span><br><span class="line"></span><br><span class="line">    int hashCode();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default Spliterator&lt;E&gt; spliterator() &#123;  // ... &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SortedSet 里面的元素一定是有序的。保证迭代器按照元素递增顺序遍历的集合，可以按照元素的自然顺序（参见 Comparable）进行排序，或者按照创建有序集合时提供的 Comparator进行排序。要采用此排序，还要提供一些其他操作。插入有序集合的所有元素都必须实现 Comparable 接口（或者被指定的 Comparator 所接受）。另外，所有这些元素都必须是可相互比较的，比如像 e1.compareTo(e2)<br>（或 comparator.compare(e1, e2)）对于有序集合中的任意元素 e1 和 e2 都不能抛出ClassCastException。试图违反这些限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。<br>注意，如果有序集合正确实现了 Set 接口，则有序集合所保持的顺序（无论是否明确提供了比较器）<br>都必须保持相等一致性。这也是因为 Set 接口是按照 equals 操作定义的，但有序集合使用它的 compareTo（或 compare）方法对所有元素进行比较，<br>因此从有序集合的观点来看，此方法认为相等的两个元素就是相等的。<br>即使顺序没有保持相等一致性，有序集合的行为仍然是 定义良好的，<br>只不过没有遵守 Set 接口的常规协定。<br>所有通用有序集合实现类都应该提供 4 个“标准”构造方法：<br>1) void（不带参数）构造方法，创建空的有序集合，按照元素的自然顺序排序。<br>2) 带有一个 Comparator 类型参数的构造方法，创建一个空的有序集合，根据指定的比较器排序。<br>3) 带有一个 Collection 类型参数的构造方法，创建一个元素与参数相同的有序集合，按照元素的自然顺序排序。<br>4) 带有一个 SortedSet 类型参数的构造方法，创建一个新的有序集合，元素及排序方法与输入的有序集合相同。<br>除了 JDK 实现（TreeSet 类）遵循此建议外，无法保证强制实施此建议（因为接口不能包含构造方法）。</p>
<p>声明的主要接口</p>
<html><head><title></title></head><body><table id="pubmethods"><tbody><tr><th colspan="12">Public Methods</th></tr><tr><td><nobr>abstract&nbsp;<a>Comparator</a>&lt;?&nbsp;super&nbsp;E&gt;</nobr></td><td width="100%"><nobr><span>comparator</span>()</nobr><div>Returns the comparator used to compare elements in this&nbsp;<code>SortedSet</code>.</div><div>返回与此有序集合关联的比较器，如果使用元素的自然顺序，则返回null。</div></td></tr><tr><td><nobr>abstract E</nobr></td><td width="100%"><nobr><span>first</span>()</nobr><div>Returns the first element in this&nbsp;<code>SortedSet</code>.</div><div>返回此有序集合中当前第一个（最小的）元素。</div></td></tr><tr><td><nobr>abstract&nbsp;<a>SortedSet</a>&lt;E&gt;</nobr></td><td width="100%"><nobr><span>headSet</span>(E end)</nobr><div>Returns a&nbsp;<code>SortedSet</code>&nbsp;which contains elements less than the end element.</div><div>用一个SortedSet,返回此有序集合中小于end的所有元素。</div></td></tr><tr><td><nobr>abstract E</nobr></td><td width="100%"><nobr><span>last</span>()</nobr><div>Returns the last element in this&nbsp;<code>SortedSet</code>.</div><div>返回此有序集合中最后一个（最大的）元素</div></td></tr><tr><td><nobr>abstract&nbsp;<a>SortedSet</a>&lt;E&gt;</nobr></td><td width="100%"><nobr><span>subSet</span>(E start,E end)</nobr><div>Returns a&nbsp;<code>SortedSet</code>&nbsp;which contains elements greater or equal to the start element but less than the end element.</div><div>返回此有序集合的部分元素，元素范围从fromElement（包括）到toElement（不包括）。</div></td></tr><tr><td><nobr>abstract&nbsp;<a>SortedSet</a>&lt;E&gt;</nobr></td><td width="100%"><nobr><span>tailSet</span>(E start)</nobr><div>Returns a&nbsp;<code>SortedSet</code>&nbsp;which contains elements greater or equal to the start element.</div><div>返回此有序集合的部分元素，其元素大于或等于fromElement。</div></td></tr></tbody></table></body></html>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/15/Java集合框架学习7/" itemprop="url">
                  Java集合框架学习(7)——Queue接口和Deque接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-15T00:24:13+08:00" content="2017-03-15">
              2017-03-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>上一篇已经讲解了List接口的一些内容，现在继续看一下Collection的另一个子接口Queue，以及Queue的子接口Deque。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    // 继承自Collection</span><br><span class="line">    boolean add(E e);  // 在队列中插入特定元素</span><br><span class="line">    </span><br><span class="line">    boolean offer(E e);  // 在队列中插入特定元素</span><br><span class="line">    </span><br><span class="line">    E remove();  // 删除并取得队列头元素</span><br><span class="line">    </span><br><span class="line">    E poll();  // 删除并取得队列头元素</span><br><span class="line">    </span><br><span class="line">    E element();  // 从头部取得元素但不删除</span><br><span class="line">    </span><br><span class="line">    E peek();  // 从头部取得元素但不删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明的这些方法中，只有Collection是继承自Collection接口的。</p>
<ul>
<li>add与offer的不同之处在于：在容量受限的队列中，offer方法比add方法更好，因为add在插入失败时仅仅抛出异常</li>
<li>remove与poll的不同之处在于：如果队列为空，remove将抛出异常，poll返回null</li>
<li>element与peek的不同之处在于：如果队列为空，element将抛出异常，peek返回null</li>
</ul>
<p>Deque是双端队列(double ended queue)的缩写，大部分Deque用于不固定元素数量的情形，当然也支持容量受限的情形。和Queue接口一样，Deque的插入、删除以及获取元素的操作都有两种形式，当操作失败时，前一种形式抛出异常，后一种形式返回特殊值(null或者false)。后一种形式的插入操作用于容量受限的Deque实现，而在大多数情况中，插入操作不会失败。</p>
<table><caption>Deque方法总结</caption><tbody><tr><td></td><td align="CENTER" colspan="2"> <b>首元素 (头)</b></td><td align="CENTER" colspan="2"> <b>尾元素 (尾)</b></td></tr> <tr> <td></td> <td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>特殊值</em></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>特殊值</em></td></tr><tr><td><b>插入</b></td><td>void addFirst(E e)</td><td>boolean offerFirst(E e)</td><td>void addLast(E e)</td><td>boolean offerLast(E e)</td></tr><tr><td><b>删除</b></td><td>E removeFirst()</td><td>E pollFirst()</td><td>E removeLast()</td><td>E pollLast()</td></tr><tr><td><b>获取</b></td><td>E getFirst()</td><td>E peekFirst()</td><td>E getLast()</td><td>E peekLast()</td></tr></tbody></table>

<p>Deque用做队列时，表现为FIFO(先入先出)，从队尾进入，从队首删除，与Queue中的一些方法等价：</p>
<table><caption>Queue和Deque方法比较</caption><tr><td align="CENTER"><b>Queue方法</b></td><td align="CENTER"><b>等价的Deque方法</b></td></tr><tr><td>boolean add(E e)</td><td>void addLast(E e)</td></tr><tr><td>boolean offer(E e)</td><td>boolean offerLast(E e)</td></tr><tr><td>E remove()</td><td>E removeFirst()</td></tr><tr><td>E poll()</td><td>E pollFirst()</td></tr><tr><td>E element()</td><td>E getFirst()</td></tr><tr><td>E peek()</td><td>E peekFirst()</td></tr></table>

<p>用做栈时，表现为LIFO(后入先出)，入栈和出栈都是从队首，与Stack中的一些方法等价：</p>
<table><caption>Deque和Stack方法比较</caption><tr><td align="center"><b>Stack方法</b></td><td align="center"><b>等价的Deque方法</b></td></tr><tr><td>E push(E e)</td><td>void addFirst(E e)</td></tr><tr><td>E pop()</td><td>E removeFirst()</td></tr><tr><td>E peek()</td><td>E peekFirst()</td></tr></table>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Deque方法总结中提到的12个方法</span><br><span class="line">    </span><br><span class="line">    boolean removeFirstOccurrence(Object o);  // 删除第一个出现的特定元素，没有该元素不发生改变</span><br><span class="line"></span><br><span class="line">    boolean removeLastOccurrence(Object o);  // 删除最后一个出现的特定元素，没有该元素不发生改变</span><br><span class="line"></span><br><span class="line">    // 继承自Queue的6个方法</span><br><span class="line"></span><br><span class="line">    // *** Stack methods ***</span><br><span class="line">    void push(E e);  // 入栈</span><br><span class="line"></span><br><span class="line">    E pop();  // 出栈</span><br><span class="line"></span><br><span class="line">    // *** Collection methods ***</span><br><span class="line">    // 继承自Collection的remove、contain、size、iterator方法</span><br><span class="line"></span><br><span class="line">    Iterator&lt;E&gt; descendingIterator();  // 返回反向迭代器，和iterator相反，实现从两端访问元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Deque接口提供了两个删除内部元素的方法，removeFirstOccurrence、removeLastOccurrence，可以避免只能从首或尾操作的麻烦。与List不同，Deque不支持通过索引的方式访问元素。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/13/Java集合框架学习6/" itemprop="url">
                  Java集合框架学习(6)——List接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-13T17:25:30+08:00" content="2017-03-13">
              2017-03-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>接着上一篇的内容，看过了Collection以后，再看一下继承了它的三个子接口List、Set、Queue<br>几种常用的数据结构如ArrayList，LinkedList等，都实现了List接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    // ... 省略已经在父接口中声明的方法</span><br><span class="line"></span><br><span class="line">    boolean addAll(int index, Collection&lt;? extends E&gt; c);  // 在List的特定位置插入某集合的全部元素</span><br><span class="line">    </span><br><span class="line">    default void replaceAll(UnaryOperator&lt;E&gt; operator)  // 替换列表中的每个数据</span><br><span class="line"></span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c)  // 使用比较器对列表排序</span><br><span class="line"></span><br><span class="line">    E get(int index);  // 得到列表指定位置的数据</span><br><span class="line"></span><br><span class="line">    E set(int index, E element);  // 替换列表中指定位置的数据</span><br><span class="line"></span><br><span class="line">    void add(int index, E element);  // 在列表的指定位置插入数据</span><br><span class="line"></span><br><span class="line">    E remove(int index);  // 删除列表中指定位置的数据或第一次出现的指定数据</span><br><span class="line"></span><br><span class="line">    int indexOf(Object o);  // 得到指定数据在列表中第一次出现的位置，如果列表中不包含指定数据，返回-1</span><br><span class="line"></span><br><span class="line">    int lastIndexOf(Object o);  // 返回指定数据在列表中最后一次出现的位置</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; listIterator();  // 返回列表的迭代器</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; listIterator(int index);  // 返回列表指定位置的迭代器</span><br><span class="line"></span><br><span class="line">    List&lt;E&gt; subList(int fromIndex, int toIndex);  // 返回列表两个位置之间的数据组成的列表</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default Spliterator&lt;E&gt; spliterator()  // 创建一个列表的分片迭代器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是一个接口继承的问题，List接口中声明了很多Collection接口中已经声明过的方法，例如size，isEmpty等，没有用@Override做注解，在这里我想为什么已经在Collection中已经声明了size方法还要在子接口List中再次声明呢？<br>我的理解是，采用这样的设计方法，将层次明确，比如一个List的实现需要size方法时指的就是这个List接口的size，后面的实现类中，明确的实现了List接口中定义的size，而非Collection接口中的size。<br>其次是几个在JDK1.8中加入的几个default方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line"></span><br><span class="line">// 将每个元素加1 </span><br><span class="line">list.replaceAll(new UnaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer apply(Integer integer) &#123;</span><br><span class="line">        return integer + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用定义的比较器对list进行排序</span><br><span class="line">list.sort(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    public int compare(String  x, String y) &#123;</span><br><span class="line">        return x.compareTo(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Spliterator方法要细说就不是这个系列所要讲述的内容了。Spliterator（splitable iterator可分割迭代器）接口是Java为了并行遍历数据源中的元素而设计的迭代器，这个可以类比最早Java提供的顺序遍历迭代器Iterator，但一个是顺序遍历，一个是并行遍历。从最早Java提供顺序遍历迭代器Iterator时，那个时候还是单核时代，但现在多核时代下，顺序遍历已经不能满足需求了，如何把多个任务分配到不同核上并行执行，才是能最大发挥多核的能力，于是有了Spliterator。以后再开一篇JDK8的讲解系列。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/12/Java集合框架学习5/" itemprop="url">
                  Java集合框架学习(5)——Collection接口和Iterable接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-12T15:05:58+08:00" content="2017-03-12">
              2017-03-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>学习各种集合容器最好先从基本接口入手，之前在<a href="http://mrcame.github.io/2017/02/10/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/" target="_blank" rel="external">《Java集合框架学习(1)——概览》</a>中已经梳理清楚了各个类和接口的脉络，现在就从最基本的Collection来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">	</span><br><span class="line">    int size();  // 返回集合中元素数量，超过最大数量后返回Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">    boolean isEmpty();  // 集合是否为空</span><br><span class="line"></span><br><span class="line">    boolean contains(Object o);  // 集合是否包含特定元素</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;E&gt; iterator();  // 返回该集合的迭代器</span><br><span class="line"></span><br><span class="line">    Object[] toArray();  // 返回一个包含集合中所有元素的数组</span><br><span class="line"></span><br><span class="line">    // 泛型方法用类型变量声明，在方法的修饰符后，返回类型的前面</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);  // 同toArray()</span><br><span class="line">    </span><br><span class="line">    boolean add(E e);  // 向集合中添加元素，返回是否添加成功</span><br><span class="line">    </span><br><span class="line">    boolean remove(Object o);  // 删除集合中的特定元素，返回是否删除成功</span><br><span class="line"></span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);  // 是否包含特定集合中的全部元素(是否为子集)</span><br><span class="line"></span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);  // 是否成功添加特定集合中的全部元素</span><br><span class="line"></span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);  // 是否删除特定集合中的全部元素</span><br><span class="line"></span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);  // 是否包含特定集合中的部分元素(是否有交集)</span><br><span class="line"></span><br><span class="line">    void clear();  // 删除集合中所有元素</span><br><span class="line"></span><br><span class="line">    // ...省略了几个default方法和Object方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样来看基本的集合操作就一目了然，需要注意的是toArray方法，有两个重构的方法，下面来看一些细节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();   </span><br><span class="line">list.add(1);  </span><br><span class="line">Integer[] i1 = (Integer[]) list.toArray();  // 造型异常</span><br><span class="line">Integer[] i2 = (Integer[]) list.toArray(new Integer[0]);  // Ok</span><br></pre></td></tr></table></figure></p>
<p>运行时会报java.lang.ClassCastException。看了一下ArrayList中toArray的实现，在不带参数的toArray方法里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 不带参数的toArray</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 带参数的toArray</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Arrays.copyOf</span><br><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;</span><br><span class="line">    return (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copyOf</span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  // 主要是这里</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用无参的toArray，在三目运算中直接返回Object数组，此时进行转型是不安全的下溯造型(Downcasting)，会产生ClassCastException，这也就是上述问题的原因了。<br>采用有参的toArray，newType.getCommponentType()返回数组内容的类型，根据该类型构造对应类型的数组copy，于是不会有问题。<br>Collection继承了Iterable接口，接下来再看一下这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; iterator();  // 返回一个迭代器</span><br><span class="line"></span><br><span class="line">    // ...省略了几个default方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档中是这样说的，只要实现了这个接口，就可以使用for-each循环来遍历目标对象。需要注意的是，Iterable这个接口比较特殊，不在java.util中。</p>
<p>下一篇来学习一下继承了Collection接口的三个基本接口——List、Set、Queue。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/27/Java集合框架学习4/" itemprop="url">
                  Java集合框架学习(4)——ArrayList中的modCount变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-27T23:56:39+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>在上一篇学习了一些ArrayList基本的API及其实现后，看一些细节性的东西，其中这个modCount变量值得注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    protected transient int modCount = 0;</span><br><span class="line">	</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modCount是定义在AbstractList中的成员变量</p>
<ul>
<li><strong>protected</strong>，说明该变量只可以在同包中的任何类、不同包中的任何当前类的子类中所访问。即不同包中的任何不是该类的子类不可访问</li>
<li><strong>transient</strong>，说明串行化时被忽略</li>
</ul>
<p>在ArrayList中与add和remove相关的操作，都会对该变量进行修改，例如remove方法中用到的fastRemove<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这个变量的作用是什么呢？ArrayList的内部类Itr实现了迭代器，其中定义了成员变量expectedModCount，在checkForComodification方法中对expectedModCount是否与ModCount相同进行了检查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        final int size = ArrayList.this.size;</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        // update once at end of iteration to reduce heap write traffic</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - 1;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可想而知，在使用迭代器遍历ArrayList时，如果使用ArrayList的add、remove方法，导致modCount改变，迭代器在检查时发现与期待的expectModCount不同，会抛出ConcurrentModificationException异常，如下例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next(); // 检查抛出异常</span><br><span class="line">            if(integer==2)</span><br><span class="line">                list.remove(integer); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么如果在迭代过程中只是将ArrayList的remove方法换成在迭代器中定义的remove方法就对了吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                iterator.remove();   //注意这个地方</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在单线程环境下确实如此，可当有多个线程对ArrayList进行操作时，线程1进行remove操作后改变了modCount值，但由于modCount不是volatile变量，线程2可能会看到原来的modCount，也可能看到新的modCount，当发现与本线程的expectModCount不同时，仍然会抛出异常。<br>即使换成Vector容器，可Vector也是继承自AbstractList，仍然会有问题。因此一般有2种解决办法：</p>
<ul>
<li>在使用iterator迭代的时候使用synchronized或者Lock进行同步；</li>
<li>使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="Carl John" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Carl John</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carl John</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
