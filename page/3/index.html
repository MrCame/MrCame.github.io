<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head><meta name="generator" content="Hexo 3.9.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">



  
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0">

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2">




  <meta name="keywords" content="Hexo,next">





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2">


<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to My World">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Welcome to My World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome to My World">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Welcome to My World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Welcome to My World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/03/12/Java集合框架学习5/" itemprop="url">
                  Java集合框架学习(5)——Collection接口和Iterable接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-12T15:05:58+08:00" content="2017-03-12">
              2017-03-12
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>学习各种集合容器最好先从基本接口入手，之前在<a href="http://mrcame.github.io/2017/02/10/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/" target="_blank" rel="noopener">《Java集合框架学习(1)——概览》</a>中已经梳理清楚了各个类和接口的脉络，现在就从最基本的Collection来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">	</span><br><span class="line">    int size();  // 返回集合中元素数量，超过最大数量后返回Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">    boolean isEmpty();  // 集合是否为空</span><br><span class="line"></span><br><span class="line">    boolean contains(Object o);  // 集合是否包含特定元素</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;E&gt; iterator();  // 返回该集合的迭代器</span><br><span class="line"></span><br><span class="line">    Object[] toArray();  // 返回一个包含集合中所有元素的数组</span><br><span class="line"></span><br><span class="line">    // 泛型方法用类型变量声明，在方法的修饰符后，返回类型的前面</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);  // 同toArray()</span><br><span class="line">    </span><br><span class="line">    boolean add(E e);  // 向集合中添加元素，返回是否添加成功</span><br><span class="line">    </span><br><span class="line">    boolean remove(Object o);  // 删除集合中的特定元素，返回是否删除成功</span><br><span class="line"></span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);  // 是否包含特定集合中的全部元素(是否为子集)</span><br><span class="line"></span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);  // 是否成功添加特定集合中的全部元素</span><br><span class="line"></span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);  // 是否删除特定集合中的全部元素</span><br><span class="line"></span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);  // 是否包含特定集合中的部分元素(是否有交集)</span><br><span class="line"></span><br><span class="line">    void clear();  // 删除集合中所有元素</span><br><span class="line"></span><br><span class="line">    // ...省略了几个default方法和Object方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样来看基本的集合操作就一目了然，需要注意的是toArray方法，有两个重构的方法，下面来看一些细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();   </span><br><span class="line">list.add(1);  </span><br><span class="line">Integer[] i1 = (Integer[]) list.toArray();  // 造型异常</span><br><span class="line">Integer[] i2 = (Integer[]) list.toArray(new Integer[0]);  // Ok</span><br></pre></td></tr></table></figure>

<p>运行时会报java.lang.ClassCastException。看了一下ArrayList中toArray的实现，在不带参数的toArray方法里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 不带参数的toArray</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 带参数的toArray</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Arrays.copyOf</span><br><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;</span><br><span class="line">    return (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copyOf</span><br><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  // 主要是这里</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用无参的toArray，在三目运算中直接返回Object数组，此时进行转型是不安全的下溯造型(Downcasting)，会产生ClassCastException，这也就是上述问题的原因了。<br>采用有参的toArray，newType.getCommponentType()返回数组内容的类型，根据该类型构造对应类型的数组copy，于是不会有问题。<br>Collection继承了Iterable接口，接下来再看一下这个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; iterator();  // 返回一个迭代器</span><br><span class="line"></span><br><span class="line">    // ...省略了几个default方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档中是这样说的，只要实现了这个接口，就可以使用for-each循环来遍历目标对象。需要注意的是，Iterable这个接口比较特殊，不在java.util中。</p>
<p>下一篇来学习一下继承了Collection接口的三个基本接口——List、Set、Queue。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/27/Java集合框架学习4/" itemprop="url">
                  Java集合框架学习(4)——ArrayList中的modCount变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-27T23:56:39+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>在上一篇学习了一些ArrayList基本的API及其实现后，看一些细节性的东西，其中这个modCount变量值得注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    protected transient int modCount = 0;</span><br><span class="line">	</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modCount是定义在AbstractList中的成员变量</p>
<ul>
<li><strong>protected</strong>，说明该变量只可以在同包中的任何类、不同包中的任何当前类的子类中所访问。即不同包中的任何不是该类的子类不可访问</li>
<li><strong>transient</strong>，说明串行化时被忽略</li>
</ul>
<p>在ArrayList中与add和remove相关的操作，都会对该变量进行修改，例如remove方法中用到的fastRemove</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个变量的作用是什么呢？ArrayList的内部类Itr实现了迭代器，其中定义了成员变量expectedModCount，在checkForComodification方法中对expectedModCount是否与ModCount相同进行了检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        final int size = ArrayList.this.size;</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        // update once at end of iteration to reduce heap write traffic</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - 1;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可想而知，在使用迭代器遍历ArrayList时，如果使用ArrayList的add、remove方法，导致modCount改变，迭代器在检查时发现与期待的expectModCount不同，会抛出ConcurrentModificationException异常，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next(); // 检查抛出异常</span><br><span class="line">            if(integer==2)</span><br><span class="line">                list.remove(integer); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果在迭代过程中只是将ArrayList的remove方法换成在迭代器中定义的remove方法就对了吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                iterator.remove();   //注意这个地方</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单线程环境下确实如此，可当有多个线程对ArrayList进行操作时，线程1进行remove操作后改变了modCount值，但由于modCount不是volatile变量，线程2可能会看到原来的modCount，也可能看到新的modCount，当发现与本线程的expectModCount不同时，仍然会抛出异常。<br>即使换成Vector容器，可Vector也是继承自AbstractList，仍然会有问题。因此一般有2种解决办法：</p>
<ul>
<li>在使用iterator迭代的时候使用synchronized或者Lock进行同步；</li>
<li>使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/27/Java-Framework1/" itemprop="url">
                  《从零开始写Java Web框架》——笔记(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-27T11:30:40+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>第一章环境搭建，第二章示范了如何使用书中所开发的Smart Framework。核心是第三章的框架实现，几个重要类的关系如下图所示：</p>
<p><img src="/images/javaFramework-1-1.png" alt="&quot;framework&quot;"></p>
<p>工具类中，核心的就是ClassUtil和ReflectionUtil了。<br>助手类中</p>
<ul>
<li><p>HelperLoader负责加载几个助手类，可以视为入口</p>
</li>
<li><p>ClassHelper提供ClassSet，包括所有类的Set或者用特定注释的类的Set。例如：用Controller注释的类的集合ControllerSet</p>
</li>
<li><p>BeanHelper根据ClassSet中的每个Class，生成对应实例，提供BeanMap&lt;Class&lt;?&gt;, Object&gt;</p>
</li>
<li><p>IocHelper根据BeanMap得到每个Bean中用Inject注释的域类型及其object，再用Reflection动态设置该值（实现依赖注入）</p>
</li>
<li><p>ControllerHelper负责在静态块中根据ControllerSet得到Controller中的Action方法，解析request方法和路径，提供ActionMap&lt;Request，Handler&gt;，将请求映射到对应的控制器</p>
</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/22/Java集合框架学习3/" itemprop="url">
                  Java集合框架学习(3)——ArrayList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-22T09:51:24+08:00" content="2017-02-22">
              2017-02-22
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>ArrayList是Java集合框架里很常用的一个数据结构，底层用数组实现数据存储，所以基本上都是对数据的操作。<br><img src="/images/java-4-0.png" alt="&quot;ArrayList&quot;"></p>
<h3 id="一些成员变量"><a href="#一些成员变量" class="headerlink" title="一些成员变量"></a>一些成员变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认数组容量</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">// 底层数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">// ArrayList包含的元素数量</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>

<p>其中，transient是Java的关键字。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。  </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ArrayList提供了三个构造函数</p>
<ul>
<li>ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。</li>
<li>ArrayList()：默认构造函数,默认为空，DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}。</li>
<li>ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在声明一个ArrayList时</p>
<ul>
<li><p><strong>ArrayList alist = new ArrayList()</strong>  用到了ArrayList的特性</p>
</li>
<li><p><strong>List list = new ArrayList()</strong>  通用性更强，可直接替换为其他List接口的实现</p>
<h3 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h3></li>
<li><p>size()，元素数量，复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isEmpty()，判断是否为空，复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return size == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>contains()，判断是否包括特定元素，复杂度O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>主要是indexOf(Object o)方法，实现了O(n)复杂度的线性查找，遍历数组，若找到则返回索引i，最坏情况遍历到最后才找到。因为ArrayList是顺序存储，如果知道存储顺序的话，可以选择用lastIndexOf(Object o)倒序遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">	if (o == null) &#123;</span><br><span class="line">		for (int i = 0; i &lt; size; i++)</span><br><span class="line">			if (elementData[i] == null)</span><br><span class="line">				return i;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for (int i = 0; i &lt; size; i++)</span><br><span class="line">			if (o.equals(elementData[i]))</span><br><span class="line">				return i;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">   public int lastIndexOf(Object o) &#123;</span><br><span class="line">       if (o == null) &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (elementData[i]==null)</span><br><span class="line">                   return i;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">               if (o.equals(elementData[i]))</span><br><span class="line">                   return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get(int index)，得到指定位置的元素，复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引越界情况</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set(int index, E element)，替换指定位置的元素，复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引越界情况</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>add(E e)，在末尾添加元素，复杂度O(1)<br>ensureCapacityInternal()方法判断是否需要扩容，grow()负责扩容操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       // 所需最小容量大于当前数组容量，扩容</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0) </span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void grow(int minCapacity) &#123;</span><br><span class="line">       int oldCapacity = elementData.length;</span><br><span class="line">	// 扩容为原来的1.5倍</span><br><span class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">	// 扩容后仍不够</span><br><span class="line">       if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       // minCapacity is usually close to size, so this is a win:</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/java-4-1.png" alt="&quot;grow&quot;"></p>
<ul>
<li><p>add(int index, E element)，在指定位置添加元素，复杂度O(n)<br>需要将该位置后的所有元素向后移动一位，复杂度取决于数组规模</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove(int index) 删除并取得指定位置的元素，复杂度O(n)<br>需要将该位置后的所有元素向前移动一位，复杂度取决于数组规模</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;  // 需要向前移动一位的元素长度</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // 清除该位置的引用，让GC起作用</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋 <strong><em>null</em></strong> 值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p>
<ul>
<li><p>remove(Object o) 删除一个元素，复杂度O(n)<br>需要遍历数组查找第一个满足条件的元素，然后把后面的元素向前前进一位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addAll()<br>一次性添加多个元素，根据位置不同也有两个把本，一个是在末尾添加的 <strong>addAll(Collection&lt;? extends E&gt; c)</strong> 方法，一个是从指定位置开始插入的 <strong>addAll(int index, Collection&lt;? extends E&gt; c)</strong> 方法。跟 <strong>add()</strong> 方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 <strong>addAll()</strong> 的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>
</li>
<li><p>removeAll(Collection&lt;?&gt; c)<br>删除指定collection中包含的所有元素，即求两个集合的差集，A-B。</p>
</li>
<li><p>retainAll(Collection&lt;?&gt; c)<br>保留指定collection中包含的所有元素，即求两个集合的交集，A∩B。</p>
</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/11/Java集合框架学习2/" itemprop="url">
                  Java集合框架学习(2)——Iterator
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-11T13:20:36+08:00" content="2017-02-11">
              2017-02-11
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p><strong>default</strong>修饰符是Java8中新的概念，在Java8发布时，需要Java在现有实现架构的下能往接口里增加新方法。引入Default方法，可以在优化接口的同时，避免跟现有实现架构的兼容问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 是否有下一元素</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    // 返回下一元素</span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">	// Default方法是指，在接口内部包含了一些默认的方法实现</span><br><span class="line">	// 也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制</span><br><span class="line">    // 从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        while (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>ListIterator继承自Iterator，除了父接口原有的方法<strong>hasNext()</strong>、<strong>next()</strong>外，还申明了新的查询操作<strong>hasPrevious()</strong>、<strong>previous()</strong>、<strong>nextIndex()</strong>、<strong>previousIndex()</strong>，以及修改操作<strong>remove()</strong>、<strong>set()</strong>、<strong>add()</strong>。相关操作见下图<br><img src="/images/java-3-0.png" alt="&quot;ListIterator&quot;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line">    // Query Operations</span><br><span class="line"></span><br><span class="line">    // 继承自父类</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    // 继承自父类</span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    // 是否有前一元素</span><br><span class="line">    boolean hasPrevious();</span><br><span class="line"></span><br><span class="line">    // 返回前一元素</span><br><span class="line">    E previous();</span><br><span class="line"></span><br><span class="line">    // 返回当前iterator的下标</span><br><span class="line">    int nextIndex();</span><br><span class="line"></span><br><span class="line">    // 返回当前iterator的前一下标，如果当前下标为0，前一下标为-1</span><br><span class="line">    int previousIndex();</span><br><span class="line"></span><br><span class="line">    // Modification Operations</span><br><span class="line"></span><br><span class="line">    // 删除元素</span><br><span class="line">    // remove当前元素必须先next()，否则remove的是前一元素</span><br><span class="line">    // 若iterator下标为0，直接remove抛出IllegalStateException异常</span><br><span class="line">    void remove();</span><br><span class="line"></span><br><span class="line">    // 替换元素</span><br><span class="line">    // 同remove，set当前元素前必须先next，否则set的是前一元素</span><br><span class="line">    // 若iterator下标为0，直接set抛出IllegalStateException异常</span><br><span class="line">    void set(E e);</span><br><span class="line"></span><br><span class="line">    // 插入元素，在该iterator的位置add</span><br><span class="line">    void add(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/10/Java集合框架学习1/" itemprop="url">
                  Java集合框架学习(1)——概览
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-10T15:12:21+08:00" content="2017-02-10">
              2017-02-10
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <hr>
<p>从源码入手学习Java集合框架，选用的JDK版本是1.8.0_111。首先当然是理清java.util下的各个集合类与接口的关系。整理了一下，如下图所示，关系应该比较清晰了吧。<br><img src="/images/java-2-0.png" alt="&quot;Collection&quot;"><br>当然经历了几个JDK版本的变化，集合框架也越来越庞大，最基本的东西却是没怎么变。<br>核心是<strong>以collection为父类的接口</strong>和<strong>以AbstractCollection为父类的抽象类</strong>，从这两部分入手，顺藤摸瓜，就可以理清整个框架的脉络，然后结合各个具体集合的实现来温习学习过的数据结构和算法。<br>比较奇怪的一点是Iterable接口是在java.lang中，而不是在java.util中。为什么Collection不直接继承Iterator呢？有这么一种说法：<br>JDK的作者之所以采用Iterator设计模式来设计，因为如果Collection直接从Iterator继承，那么Collection的实现类必须直接实现hasNext, next, remove方法。这么做有以下缺点：</p>
<ul>
<li>这么做会造成代码混乱，迭代代码与Collection本身实现代码混淆在一起，造成阅读困难，而且有方法重复，比如remove，不能做到迭代与本身实现分离。</li>
<li>在Collection实现类中必须包含当前cursor指针，在并发时处理相当尴尬。</li>
<li>访问接口不统一，Collection从Iterable继承的话，在迭代时只需拿到其Iterator(内部类实现)，用统一的对象迭代，而且多个迭代器可以做到互不干扰。</li>
</ul>
<p>从接口看，整体可以分为两大类：Collection和Map。因为Map表示的是关联式容器。接下来，将从比较独立的Iterator来进行分析。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/09/Java中的编码问题2/" itemprop="url">
                  Java 的中文编码问题(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-09T14:18:20+08:00" content="2017-02-09">
              2017-02-09
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>引自<a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">《深入分析Java中的中文编码问题》</a></p>
<hr>
<h2 id="Java-Web-涉及到的编码"><a href="#Java-Web-涉及到的编码" class="headerlink" title="Java Web 涉及到的编码"></a>Java Web 涉及到的编码</h2><p>对于使用中文来说，有 I/O 的地方就会涉及到编码，前面已经提到了 I/O 操作会引起编码，而大部分 I/O 引起的乱码都是网络 I/O，因为现在几乎所有的应用程序都涉及到网络操作，而数据经过网络传输都是以字节为单位的，所以所有的数据都必须能够被序列化为字节。在 Java 中数据被序列化必须继承 Serializable 接口。<br>原文中，作者提出这这样一个问题，我们是否认真考虑过一段文本它的实际大小应该怎么计算，他曾经碰到过一个问题：就是要想办法压缩 Cookie 大小，减少网络传输量，当时有选择不同的压缩算法，发现压缩后字符数是减少了，但是并没有减少字节数。所谓的压缩只是将多个单字节字符通过编码转变成一个多字节字符。减少的是 String.length()，而并没有减少最终的字节数。例如将“ab”两个字符通过某种编码转变成一个奇怪的字符，虽然字符数从两个变成一个，但是如果采用 UTF-8 编码这个奇怪的字符最后经过编码可能又会变成三个或更多的字节。同样的道理比如整型数字 1234567 如果当成字符来存储，采用 UTF-8 来编码占用 7 个 byte，采用 UTF-16 编码将会占用 14 个 byte，但是把它当成 int 型数字来存储只需要 4 个 byte 来存储。所以看一段文本的大小，看字符本身的长度是没有意义的，即使是一样的字符采用不同的编码最终存储的大小也会不同，所以从字符到字节一定要看编码类型。<br>另外一个问题，我们是否考虑过，当我们在电脑中某个文本编辑器里输入某个汉字时，它到底是怎么表示的？我们知道，计算机里所有的信息都是以 01 表示的，那么一个汉字，它到底是多少个 0 和 1 呢？我们能够看到的汉字都是以字符形式出现的，例如在 Java 中“淘宝”两个字符，它在计算机中的数值 10 进制是 28120 和 23453，16 进制是 6bd8 和 5d9d，也就是这两个字符是由这两个数字唯一表示的。Java 中一个 char 是 16 个 bit 相当于两个字节，所以两个汉字用 char 表示在内存中占用相当于四个字节的空间。<br>这两个问题搞清楚后，再来看一下 Java Web 中那些地方可能会存在编码转换？<br>用户从浏览器端发起一个 HTTP 请求，需要存在编码的地方是 URL、Cookie、Parameter。服务器端接受到 HTTP 请求后要解析 HTTP 协议，其中 URI、Cookie 和 POST 表单参数需要解码，服务器端可能还需要读取数据库中的数据，本地或网络中其它地方的文本文件，这些数据都可能存在编码问题，当 Servlet 处理完所有请求的数据后，需要将这些数据再编码通过 Socket 发送到用户请求的浏览器里，再经过浏览器解码成为文本。这些过程如下图所示：<br><img src="/images/java-1-0.png" alt="&quot;HTTP请求&quot;"><br>如上图所示一次 HTTP 请求设计到很多地方需要编解码，它们编解码的规则是什么？下面将会重点阐述一下：</p>
<hr>
<h3 id="URL的编解码"><a href="#URL的编解码" class="headerlink" title="URL的编解码"></a>URL的编解码</h3><p>用户提交一个 URL，这个 URL 中可能存在中文，因此需要编码，如何对这个 URL 进行编码？根据什么规则来编码？有如何来解码？如下图一个 URL：<br><img src="/images/java-1-1.png" alt="&quot;URL&quot;"><br>上图中以 Tomcat 作为 Servlet Engine 为例，它们分别对应到下面这些配置文件中：<br>Port 对应在 Tomcat 的 <connector port="8080"> 中配置，而 Context Path 在 <context path="/examples"> 中配置，Servlet Path 在 Web 应用的 web.xml 中的</context></connector></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">       &lt;servlet-name&gt;junshanExample&lt;/servlet-name&gt; </span><br><span class="line">       &lt;url-pattern&gt;/servlets/servlet/*&lt;/url-pattern&gt; </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p><url-pattern> 中配置，PathInfo 是我们请求的具体的 Servlet，QueryString 是要传递的参数，注意这里是在浏览器里直接输入 URL 所以是通过 Get 方法请求的，如果是 POST 方法请求的话，QueryString 将通过表单方式提交到服务器端，这个将在后面再介绍。<br>上图中 PathInfo 和 QueryString 出现了中文，当我们在浏览器中直接输入这个 URL 时，在浏览器端和服务端会如何编码和解析这个 URL 呢？为了验证浏览器是怎么编码 URL 的我们选择 FireFox 浏览器并通过 HTTPFox 插件观察我们请求的 URL 的实际的内容，以下是 URL：</url-pattern></p>
<blockquote>
<p><a href="HTTP://localhost:8080/examples/servlets/servlet/" target="_blank" rel="noopener">HTTP://localhost:8080/examples/servlets/servlet/</a> 君山 ?author= 君山</p>
</blockquote>
<p>在中文 FireFox3.6.12 的测试结果<br><img src="/images/java-1-2.png" alt="&quot;Test&quot;"><br>君山的编码结果分别是：e5 90 9b e5 b1 b1，be fd c9 bd，查阅上一届的编码可知，PathInfo 是 UTF-8 编码而 QueryString 是经过 GBK 编码，至于为什么会有“%”？查阅 URL 的编码规范 RFC3986 可知浏览器编码 URL 是将非 ASCII 字符按照某种编码格式编码成 16 进制数字然后将每个 16 进制表示的字节前加上“%”，所以最终的 URL 就成了上图的格式了。<br>默认情况下中文 IE 最终的编码结果也是一样的，不过 IE 浏览器可以修改 URL 的编码格式在选项 -&gt; 高级 -&gt; 国际里面的发送 UTF-8 URL 选项可以取消。<br>从上面测试结果可知浏览器对 PathInfo 和 QueryString 的编码是不一样的，不同浏览器对 PathInfo 也可能不一样，这就对服务器的解码造成很大的困难，下面我们以 Tomcat 为例看一下，Tomcat 接受到这个 URL 是如何解码的。<br>解析请求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，这个方法把传过来的 URL 的 byte[] 设置到 org.apache.coyote.Request 的相应的属性中。这里的 URL 仍然是 byte 格式，转成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void convertURI(MessageBytes uri, Request request) </span><br><span class="line"> throws Exception &#123; </span><br><span class="line">        ByteChunk bc = uri.getByteChunk(); </span><br><span class="line">        int length = bc.getLength(); </span><br><span class="line">        CharChunk cc = uri.getCharChunk(); </span><br><span class="line">        cc.allocate(length, -1); </span><br><span class="line">        String enc = connector.getURIEncoding(); </span><br><span class="line">        if (enc != null) &#123; </span><br><span class="line">            B2CConverter conv = request.getURIConverter(); </span><br><span class="line">            try &#123; </span><br><span class="line">                if (conv == null) &#123; </span><br><span class="line">                    conv = new B2CConverter(enc); </span><br><span class="line">                    request.setURIConverter(conv); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; catch (IOException e) &#123;...&#125; </span><br><span class="line">            if (conv != null) &#123; </span><br><span class="line">                try &#123; </span><br><span class="line">                    conv.convert(bc, cc, cc.getBuffer().length - </span><br><span class="line"> cc.getEnd()); </span><br><span class="line">                    uri.setChars(cc.getBuffer(), cc.getStart(), </span><br><span class="line"> cc.getLength()); </span><br><span class="line">                    return; </span><br><span class="line">                &#125; catch (IOException e) &#123;...&#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        // Default encoding: fast conversion </span><br><span class="line">        byte[] bbuf = bc.getBuffer(); </span><br><span class="line">        char[] cbuf = cc.getBuffer(); </span><br><span class="line">        int start = bc.getStart(); </span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123; </span><br><span class="line">            cbuf[i] = (char) (bbuf[i + start] &amp; 0xff); </span><br><span class="line">        &#125; </span><br><span class="line">        uri.setChars(cbuf, 0, length); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以知道对 URL 的 URI 部分进行解码的字符集是在 connector 的 <connector uriencoding="UTF-8"> 中定义的，如果没有定义，那么将以默认编码 ISO-8859-1 解析。所以如果有中文 URL 时最好把 URIEncoding 设置成 UTF-8 编码。<br>QueryString 又如何解析？ GET 方式 HTTP 请求的 QueryString 与 POST 方式 HTTP 请求的表单参数都是作为 Parameters 保存，都是通过 request.getParameter 获取参数值。对它们的解码是在 request.getParameter 方法第一次被调用时进行的。request.getParameter 方法被调用时将会调用 org.apache.catalina.connector.Request 的 parseParameters 方法。这个方法将会对 GET 和 POST 方式传递的参数进行解码，但是它们的解码字符集有可能不一样。POST 表单的解码将在后面介绍，QueryString 的解码字符集是在哪定义的呢？它本身是通过 HTTP 的 Header 传到服务端的，并且也在 URL 中，是否和 URI 的解码字符集一样呢？从前面浏览器对 PathInfo 和 QueryString 的编码采取不同的编码格式不同可以猜测到解码字符集肯定也不会是一致的。的确是这样 QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 <connector uriencoding="”UTF-8”" usebodyencodingforuri="”true”/"> 中的 useBodyEncodingForURI 设置为 true。这个配置项的名字有点让人产生混淆，它并不是对整个 URI 都采用 BodyEncoding 进行解码而仅仅是对 QueryString 使用 BodyEncoding 解码，这一点还要特别注意。<br>从上面的 URL 编码和解码过程来看，比较复杂，而且编码和解码并不是我们在应用程序中能完全控制的，所以在我们的应用程序中应该尽量避免在 URL 中使用非 ASCII 字符，不然很可能会碰到乱码问题，当然在我们的服务器端最好设置 <connector> 中的 URIEncoding 和 useBodyEncodingForURI 两个参数。</connector></connector></connector></p>
<hr>
<h3 id="HTTP-Header-的编解码"><a href="#HTTP-Header-的编解码" class="headerlink" title="HTTP Header 的编解码"></a>HTTP Header 的编解码</h3><p>当客户端发起一个 HTTP 请求除了上面的 URL 外还可能会在 Header 中传递其它参数如 Cookie、redirectPath 等，这些用户设置的值很可能也会存在编码问题，Tomcat 对它们又是怎么解码的呢？<br>对 Header 中的项进行解码也是在调用 request.getHeader 是进行的，如果请求的 Header 项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASCII 字符解码肯定会有乱码。<br>我们在添加 Header 时也是同样的道理，不要在 Header 中传递非 ASCII 字符，如果一定要传递的话，我们可以先将这些字符用 org.apache.catalina.util.URLEncoder 编码然后再添加到 Header 中，这样在浏览器到服务器的传递过程中就不会丢失信息了，如果我们要访问这些项时再按照相应的字符集解码就好了。</p>
<hr>
<h3 id="POST-表单的编解码"><a href="#POST-表单的编解码" class="headerlink" title="POST 表单的编解码"></a>POST 表单的编解码</h3><p>在前面提到了 POST 表单提交的参数的解码是在第一次调用 request.getParameter 发生的，POST 表单参数传递方式与 QueryString 不同，它是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端，在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置。<br>另外针对 multipart/form-data 类型的参数，也就是上传的文件编码同样也是使用 ContentType 定义的字符集编码，值得注意的地方是上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及到字符编码，而真正编码是在将文件内容添加到 parameters 中，如果用这个编码不能编码时将会用默认编码 ISO-8859-1 来编码。</p>
<hr>
<h3 id="HTTP-BODY-的编解码"><a href="#HTTP-BODY-的编解码" class="headerlink" title="HTTP BODY 的编解码"></a>HTTP BODY 的编解码</h3><p>当用户请求的资源已经成功获取后，这些内容将通过 Response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端，浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 <meta http-equiv="Content-Type" content="text/html; charset=GBK"> 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。</p>
<hr>
<h3 id="其它需要编码的地方"><a href="#其它需要编码的地方" class="headerlink" title="其它需要编码的地方"></a>其它需要编码的地方</h3><p>除了 URL 和参数编码问题外，在服务端还有很多地方可能存在编码，如可能需要读取 xml、velocity 模版引擎、JSP 或者从数据库读取数据等。<br>xml 文件可以通过设置头来制定编码格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br></pre></td></tr></table></figure>

<p>Velocity 模版设置编码格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.VelocityService.input.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<p>JSP 设置编码格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;</span><br></pre></td></tr></table></figure>

<p>访问数据库都是通过客户端 JDBC 驱动来完成，用 JDBC 来存取数据要和数据的内置编码保持一致，可以通过设置 JDBC URL 来制定如 MySQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题分析"><a href="#常见问题分析" class="headerlink" title="常见问题分析"></a>常见问题分析</h3><p>在了解了 Java Web 中可能需要编码的地方后，下面看一下，当我们碰到一些乱码时，应该怎么处理这些问题？出现乱码问题唯一的原因都是在 char 到 byte 或 byte 到 char 转换中编码和解码的字符集不一致导致的，由于往往一次操作涉及到多次编解码，所以出现乱码时很难查找到底是哪个环节出现了问题，下面就几种常见的现象进行分析。</p>
<ul>
<li><strong>中文变成了看不懂的字符</strong><br>　　例如，字符串“淘！我喜欢！”变成了“Ì Ô £ ¡Î Ò Ï²»¶ £ ¡”编码过程如下图所示:<br><img src="/images/java-1-3.png" alt="&quot;1&quot;"><br>　　字符串在解码时所用的字符集与编码字符集不一致导致汉字变成了看不懂的乱码，而且是一个汉字字符变成两个乱码字符。</li>
<li><strong>一个汉字变成一个问号</strong><br>　　例如，字符串“淘！我喜欢！”变成了“？？？？？？”编码过程如下图所示<br><img src="/images/java-1-4.png" alt="&quot;2&quot;"><br>　　将中文和中文符号经过不支持中文的 ISO-8859-1 编码后，所有字符变成了“？”，这是因为用 ISO-8859-1 进行编解码时遇到不在码值范围内的字符时统一用 3f 表示，这也就是通常所说的“黑洞”，所有 ISO-8859-1 不认识的字符都变成了“？”。</li>
<li><strong>一个汉字变成两个问号</strong><br>　　例如，字符串“淘！我喜欢！”变成了“？？？？？？？？？？？？”编码过程如下图所示<br><img src="/images/java-1-5.png" alt="&quot;3&quot;"><br>　　这种情况比较复杂，中文经过多次编码，但是其中有一次编码或者解码不对仍然会出现中文字符变成“？”现象，出现这种情况要仔细查看中间的编码环节，找出出现编码错误的地方。</li>
<li><strong>一种不正常的正确编码</strong><br>　　还有一种情况是在我们通过 request.getParameter 获取参数值时，当我们直接调用<code>String value = request.getParameter(name);</code><br>　　会出现乱码，但是如果用下面的方式<code>String value = String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</code><br>　　解析时取得的 value 会是正确的汉字字符，这种情况是怎么造成的呢？看下如所示：<br><img src="/images/java-1-6.png" alt="&quot;4&quot;"><br>　　这种情况是这样的，ISO-8859-1 字符集的编码范围是 0000-00FF，正好和一个字节的编码范围相对应。这种特性保证了使用 ISO-8859-1 进行编码和解码可以保持编码数值“不变”。虽然中文字符在经过网络传输时，被错误地“拆”成了两个欧洲字符，但由于输出时也是用 ISO-8859-1，结果被“拆”开的中文字的两半又被合并在一起，从而又刚好组成了一个正确的汉字。虽然最终能取得正确的汉字，但是还是不建议用这种不正常的方式取得参数值，因为这中间增加了一次额外的编码与解码，这种情况出现乱码时因为 Tomcat 的配置文件中 useBodyEncodingForURI 配置项没有设置为”true”，从而造成第一次解析式用 ISO-8859-1 来解析才造成乱码的。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　本文首先总结了几种常见编码格式的区别，然后介绍了支持中文的几种编码格式，并比较了它们的使用场景。接着介绍了 Java 那些地方会涉及到编码问题，已经 Java 中如何对编码的支持。并以网络 I/O 为例重点介绍了 HTTP 请求中的存在编码的地方，以及 Tomcat 对 HTTP 协议的解析，最后分析了我们平常遇到的乱码问题出现的原因。<br>　　综上所述，要解决中文问题，首先要搞清楚哪些地方会引起字符到字节的编码以及字节到字符的解码，最常见的地方就是读取会存储数据到磁盘，或者数据要经过网络传输。然后针对这些地方搞清楚操作这些数据的框架的或系统是如何控制编码的，正确设置编码格式，避免使用软件默认的或者是操作系统平台默认的编码格式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.unicode.org/charts/" target="_blank" rel="noopener">《Unicode 编码规范》</a>，详细描述了 Unicode 如何编码。<br><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noopener">《ISO-8859-1 编码》</a>，详细介绍了 ISO-8859-1 的一些细节。<br><a href="http://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener">《RFC3986 规范》</a>，详细描述了 URL 编码规范。<br><a href="http://www.w3.org/Protocols/" target="_blank" rel="noopener">《HTTP 协议》</a>，W3C 关于 HTTP 协议的详细描述。<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">《Tomcat 系统架构与设计模式》</a>，了解 Tomcat 中容器的体系结构，基本的工作原理，以及 Tomcat 中使用的经典的设计模式介绍。<br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">《Servlet 工作原理解析》</a>，以 Tomcat 为例了解 Servlet 容器是如何工作的。<br><a href="http://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">developerWorks Java 技术专区</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2017/02/09/Java中的编码问题1/" itemprop="url">
                  Java 的中文编码问题(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-09T11:41:25+08:00" content="2017-02-09">
              2017-02-09
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>引自<a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">《深入分析Java中的中文编码问题》</a></p>
<hr>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ul>
<li>计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个</li>
<li>人类要表示的符号太多，无法用一个字节来完全表示</li>
<li>要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码</li>
</ul>
<h2 id="常见的编码格式"><a href="#常见的编码格式" class="headerlink" title="常见的编码格式"></a>常见的编码格式</h2><ul>
<li><p>ASCII<br>ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
</li>
<li><p>ISO-8859-1<br>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
</li>
<li><p>GB2312<br>它的全称是《信息交换用汉字编码字符集基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
</li>
<li><p>GBK<br>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
</li>
<li><p>GB18030<br>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
</li>
<li><p>UTF-16<br>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
</li>
<li><p>UTF-8<br>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。<br>UTF-8 有以下编码规则：</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。<ul>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Java中的编解码"><a href="#Java中的编解码" class="headerlink" title="Java中的编解码"></a>Java中的编解码</h2><p><strong>解码：字节-&gt;字符</strong>　　<strong>编码：字符-&gt;字节</strong></p>
<h3 id="IO中的编解码"><a href="#IO中的编解码" class="headerlink" title="IO中的编解码"></a>IO中的编解码</h3><p>根据处理数据类型的不同分为：字符流(byte) 字节流(char)<br>根据数据流向不同分为：输入流(读，外存-&gt;内存) 输出流(写，内存-&gt;外存)<br>字符流：Reader，Writer<br>字节流：InputStream, OutputStream<br>桥梁：InputStreamReader(字节-&gt;字符) OutputStreamWriter(字符-&gt;字节)</p>
<p>InputStreamReader具体的解码由 StreamDecoder 实现，将字节解码成字符，解码过程中必须由用户指定 Charset 格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。<br><img src="/images/java-0-0.png" alt="&quot;Input&quot;"></p>
<p>同样，OutputStreamWriter具体的编码由 StreamEncoder 实现，将字符编码成字节，编码格式和默认编码规则与解码是一致的。<br><img src="/images/java-0-1.png" alt="&quot;Output&quot;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String file = &quot;c:/stream.txt&quot;; </span><br><span class="line">String charset = &quot;UTF-8&quot;;  // 编码格式</span><br><span class="line"></span><br><span class="line">// 写字符换转成字节流</span><br><span class="line">FileOutputStream outputStream = new FileOutputStream(file);</span><br><span class="line">OutputStreamWriter writer = new OutputStreamWriter( </span><br><span class="line">outputStream, charset);</span><br><span class="line">try &#123; </span><br><span class="line">   writer.write(&quot;这是要保存的中文字符&quot;); </span><br><span class="line">&#125; finally &#123; </span><br><span class="line">   writer.close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 读取字节转换成字符</span><br><span class="line">FileInputStream inputStream = new FileInputStream(file); </span><br><span class="line">InputStreamReader reader = new InputStreamReader( </span><br><span class="line">inputStream, charset); </span><br><span class="line">StringBuffer buffer = new StringBuffer(); </span><br><span class="line">char[] buf = new char[64]; </span><br><span class="line">int count = 0; </span><br><span class="line">try &#123; </span><br><span class="line">   while ((count = reader.read(buf)) != -1) &#123; </span><br><span class="line">       buffer.append(buffer, 0, count); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; finally &#123; </span><br><span class="line">   reader.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存中的编解码"><a href="#内存中的编解码" class="headerlink" title="内存中的编解码"></a>内存中的编解码</h3><p>在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;这是一段中文字符串&quot;; </span><br><span class="line">byte[] b = s.getBytes(&quot;UTF-8&quot;); </span><br><span class="line">String n = new String(b,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>另外一个是已经被被废弃的 ByteToCharConverter 和 CharToByteConverter 类，它们被 Charset 类取代。Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(&quot;UTF-8&quot;); </span><br><span class="line">ByteBuffer byteBuffer = charset.encode(string); </span><br><span class="line">CharBuffer charBuffer = charset.decode(byteBuffer);</span><br></pre></td></tr></table></figure>

<h3 id="Java中具体的编解码实例"><a href="#Java中具体的编解码实例" class="headerlink" title="Java中具体的编解码实例"></a>Java中具体的编解码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class IOTest &#123;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        String s = &quot;I am 君山&quot;;</span><br><span class="line">        encode(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void encode(String s) &#123;</span><br><span class="line">        toHex(s.toCharArray());</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] iso8859 = s.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">            toHex(iso8859, &quot;iso8859&quot;);</span><br><span class="line">            byte[] gb2312 = s.getBytes(&quot;GB2312&quot;);</span><br><span class="line">            toHex(gb2312, &quot;gb2312&quot;);</span><br><span class="line">            byte[] gbk = s.getBytes(&quot;GBK&quot;);</span><br><span class="line">            toHex(gbk, &quot;gbk&quot;);</span><br><span class="line">            byte[] utf16 = s.getBytes(&quot;UTF-16&quot;);</span><br><span class="line">            toHex(utf16, &quot;utf16&quot;);</span><br><span class="line">            byte[] utf8 = s.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            toHex(utf8, &quot;utf8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void toHex(char[] c) &#123;</span><br><span class="line">        System.out.println(&quot;-------- char[] --------&quot;);</span><br><span class="line">        String s = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; c.length; i++)</span><br><span class="line">            s += Integer.toHexString(c[i]) + &quot; &quot;;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void toHex(byte[] b, String charset) &#123;</span><br><span class="line">        System.out.println(&quot;------&quot; + charset + &quot;-------&quot;);</span><br><span class="line">        for (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%x&quot;, b[i]);</span><br><span class="line">            System.out.print(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------- char[] --------</span><br><span class="line">49 20 61 6d 20 541b 5c71 </span><br><span class="line">------iso8859-------</span><br><span class="line">49 20 61 6d 20 3f 3f </span><br><span class="line">------gb2312-------</span><br><span class="line">49 20 61 6d 20 be fd c9 bd </span><br><span class="line">------gbk-------</span><br><span class="line">49 20 61 6d 20 be fd c9 bd </span><br><span class="line">------utf16-------</span><br><span class="line">fe ff 0 49 0 20 0 61 0 6d 0 20 54 1b 5c 71 </span><br><span class="line">------utf8-------</span><br><span class="line">49 20 61 6d 20 e5 90 9b e5 b1 b1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ISO-8859-1<br><img src="/images/java-0-2.png" alt="&quot;ISO-8859-1&quot;"><br>7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题。</p>
</li>
<li><p>GB2312<br><img src="/images/java-0-3.png" alt="&quot;GB2312&quot;"><br>GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。如果查到的码位值大于 oxff 则是双字节，否则是单字节。双字节高 8 位作为第一个字节，低 8 位作为第二个字节</p>
</li>
<li><p>GBK<br><img src="/images/java-0-4.png" alt="&quot;GBK&quot;"><br>与 GB2312 编码的结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。</p>
</li>
<li><p>UTF-16<br><img src="/images/java-0-5.png" alt="&quot;UTF-16&quot;"><br>用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值。<strong>(UTF16打印结果中的前两个字节fe ff，因为在Windows平台下默认的Unicode编码为Little-endian的UTF-16)</strong>UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。</p>
</li>
<li><p>UTF-8<br><img src="/images/java-0-6.png" alt="&quot;UTF-8&quot;"><br>UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。</p>
</li>
</ul>
<p><strong>UTF-8 编码与 GBK 和 GB2312 不同，不用查码表，所以在编码效率上 UTF-8 的效率会更好，所以在存储中文字符时 UTF-8 编码比较理想。</strong></p>
<h3 id="几种编码格式的比较"><a href="#几种编码格式的比较" class="headerlink" title="几种编码格式的比较"></a>几种编码格式的比较</h3><p>对中文字符后面四种编码格式都能处理，GB2312 与 GBK 编码规则类似，但是 GBK 范围更大，它能处理所有汉字字符，所以 GB2312 与 GBK 比较应该选择 GBK。UTF-16 与 UTF-8 都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，想比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/05/05/hexo-1/" itemprop="url">
                  Hexo的NexT主题默认显示侧边栏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-05T00:15:01+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>用Hexo的Next主题有一段时间了，但是发觉边框栏即便设置了 <code>sidebar: always</code>，也不能自动展开</p>
<p>在网上查了查，找到了<a href http: www.jianshu.com p 29589e303f4d"">解决办法</a></p>
<p>在 <code>\themes\next\source\js\motion_global.js</code> 做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sidebarToggle: function (integrator) &#123;</span><br><span class="line">    sidebarToggleMotion.init();</span><br><span class="line">    integrator.next();</span><br><span class="line">    // 可以不加if直接显示</span><br><span class="line">    // 加if的话，要在主题配置文件里面修改 sidebar: always</span><br><span class="line">    if (CONFIG.sidebar === &apos;always&apos;) &#123;</span><br><span class="line">       // 模拟点击一下侧边栏按钮</span><br><span class="line">       sidebarToggleMotion.clickHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈哈，边框栏可以自动展开啦！开心</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/05/04/PHP-MySql-Apache-WordPress/" itemprop="url">
                  PHP+MySql+Apache+WordPress Win10 配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-04T22:48:32+08:00" content="2016-05-04">
              2016-05-04
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/搭建环境/" itemprop="url" rel="index">
                    <span itemprop="name">搭建环境</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>闲话少说，首先是安装，但是版本的选择很重要。</p>
<h2 id="PHP-5-6"><a href="#PHP-5-6" class="headerlink" title="PHP 5.6"></a>PHP 5.6</h2><p>当然是<a href http: php.net downloads.php"">官网</a>啦！</p>
<p><img src="/images/amps1.png" alt="“php1”"></p>
<p>这里选择5.6的版本，PHP 7太新了，怕兼容性出现问题。点击<a href http: windows.php.net download#php-5.6"">Windows downloads</a></p>
<p>版本有Thread Safe/Non Thread Safe 和 X86 X64的两种组合，随自己的喜欢了。Non Thread Safe不会检查线程是否安全。这里下载的是Zip格式的压缩包</p>
<p><img src="/images/amps2.png" alt="“php2”"></p>
<p>解压缩，我的路径是 F:\php5.6 复制份php.ini-development，并改名为PHP.ini，用记事本打开</p>
<p>查找 extension_dir 将</p>
<pre><code>;extension=php_mysql.dll
;extension=php_mysqli.dll</code></pre><p>前面的注释符”;”去掉，使PHP支持mysql</p>
<h2 id="Apache-2-4"><a href="#Apache-2-4" class="headerlink" title="Apache 2.4"></a>Apache 2.4</h2><p>点<a href http: httpd.apache.org download.cgi"">这里</a>下载！这里选择2.4版本，因为和PHP 5.6一样都是在vc11下编译的</p>
<p><img src="/images/amps3.png" alt="“apache1”"></p>
<p>点击 Files for Microsoft Windows，这里有五个版本，第一项ApacheHaus是个第三方下载平台，在它的网站下载独立的Apache压缩包。另外四个中，第二个也是独立的Apache下载地址，另外三个是集成开发环境。这里直接选择了第一个</p>
<p><img src="/images/amps4.png" alt="“apache2”"></p>
<p>解压缩，我的路径是 F:\Apache24 接下来的工作就是比较主要的了，配置 httpd.conf</p>
<ul>
<li>修改监听端口</li>
</ul>
<p>如果原有80端口被其他服务占用，可以修改 <code>Listen 80</code> 为 <code>Listen 8081</code> (例如)</p>
<ul>
<li>修改权限</li>
</ul>
<p>apache 2.4 不再支持deny/allow 等指令，改用 denied/granted，将denied改为granted，或者注释掉重写。<br>否则会出现的一个问题是 <code>You don’t have permission to access / on this server</code><br>如果根目录下没有index文件，也会出现这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">    AllowOverride none</span><br><span class="line">    # Require all denied</span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改站点根目录</li>
</ul>
<p><code>DocumentRoot &quot;${SRVROOT}/htdocs&quot;</code> 改为自己的目录<br>例如我的 <code>DocumentRoot &quot;D:/PHPWeb&quot;</code></p>
<ul>
<li>支持PHP</li>
</ul>
<p>在配置文件最后添加以下代码，配置php的module 和 php.ini 的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># php5 support</span><br><span class="line">LoadModule php5_module &quot;F:/php5.6/php5apache2_4.dll&quot;</span><br><span class="line">AddHandler application/x-httpd-php .php</span><br><span class="line"># configure the path to php.ini</span><br><span class="line">PHPIniDir &quot;F:/php5.6&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动Apache</li>
</ul>
<p>在bin目录下执行httpd.exe，正常情况就是没有信息返回</p>
<p><img src="/images/amps5.png" alt="“apache3”"></p>
<p>在 <code>D:/PHPWeb</code> 内新建 <code>index.php</code>, 内容填入以下PHP代码</p>
<pre><code>&lt;?php Echo &quot;Hello, CJW!&quot;;?&gt;</code></pre><p>此时可以在浏览器输入localhost:8081/index.php，可以看到打印的结果，此时PHP+Apache已经搭建好</p>
<p><img src="/images/amps6.png" alt="“apache4”"></p>
<h2 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h2><p>点<a href https: wordpress.org download "">这里</a>下载，我选择zip版本，然后解压缩</p>
<p><a href http: codex.wordpress.org.cn "">官网教程</a>写的也比较清楚，主要有几个步骤需要注意</p>
<ul>
<li>上传WordPress到一个远程主机</li>
</ul>
<p>教程里说的这一步，可以把zip解压到根目录里，例如我的 <code>&quot;D:\PHPWeb\wordpress&quot;</code></p>
<ul>
<li>设置 wp-config.php</li>
</ul>
<p>将 wp-config-sample.php 改名为 wp-config.php，然后就是配置数据库，教程里写的很清楚。</p>
<ul>
<li>测试</li>
</ul>
<p>在浏览器里输入 <code>http://localhost:8081/wordpress/</code> 进行测试，第一次访问是注册界面</p>
<p>如果出现 <code>You don’t have permission to access / on this server</code> 检查Apache配置，或者看是否缺少index文件</p>
<p><img src="/images/amps7.png" alt="“wp”"></p>
<h2 id="MySql-5-6"><a href="#MySql-5-6" class="headerlink" title="MySql 5.6"></a>MySql 5.6</h2><p>安装过程基本一路next，注意填入的用户名和密码要记住，在wp-config.php配置时需要填入</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="Carl John" itemprop="image">
          <p class="site-author-name" itemprop="name">Carl John</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">48</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carl John</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
